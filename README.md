## Aim: Demonstrating the Observer Design Pattern combined with web dashboard using Flask and Flask-SocketIO
## Solution:
Packages are installed as mentioned in the requirements.txt file<br>
templates/dashboard.html file: it contains the basic html code containing the machine and their states to the best of my knowledge.<br>
main_web_socket.py file: This file contains the code where each machine is modeled as a subject that maintains a state such as PRODUCING, IDLE, or STARVED, while the dashboard acts as an observer that registers interest in those machines. When a machine’s state changes, it automatically notifies the dashboard through the observer mechanism. The dashboard then makes the updated machine name and state to connected web clients using WebSockets, allowing the frontend to update instantly without refreshing the page. A background thread continuously simulates machine activity by randomly changing each machine’s state at fixed intervals, creating a live, real-time production line dashboard suitable for monitoring and visualization purposes.<br>
main.py file: This is the additional file containing APIs to check if the simulation is running properly. The dashboard acts as that observer, registering itself with each machine when the application starts. Whenever a machine’s state is updated, it automatically notifies the dashboard, which stores the latest state for that machine in memory. Flask exposes this information through a REST API wjere one endpoint returns the current state of all machines, and another allows a client to update the state of a specific machine.
